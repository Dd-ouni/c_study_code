#include <iostream>
#include <bitset>
using namespace std;

// 位运算之左右位移

void test01() {
  short sh{ 0b1111111111111111 };
  cout << bitset<16>(sh) << endl;

  sh <<= 2; // sh <<= 2 等价于 sh = sh << 2;
  // 左移2位补0
  cout << bitset<16>(sh) << endl;
  /* 结果
  1111111111111111
  1111111111111100
  */
  sh >>= 2;
  // 右移2位补1，为什么不上补0呢
  cout << bitset<16>(sh) << endl;
  /*
    1111111111111111
    1111111111111100
    1111111111111111   我们要的结果应该是 0011111111111100
    因为sh是有符号的，有符号为了实现负数，有一半是负数
  */
  using UNShort = unsigned short;
  cout << ((UNShort)sh) << endl;
  cout << bitset<16>(((UNShort)sh >>2)) << char(10);
  /*
    无符号右移最高位补0
    1111111111111111
    1111111111111100
    1111111111111111
    65535
    0011111111111111
  */
  
  // 左移和右移的作用
  /*
     999 <<= 1 等于 9990 等于 翻倍(进制)
     举例10进制，左位移1位是什么效果
     如果有十进制位移，那么十进制的左移即翻10倍
     左移两位即100倍

     二进制的左移运算符是 翻2倍
     0001 <<= 1 
     等于 1 * 2 等于 0001 + 0001 等于 0010
     0001 <<= 2
     0100 等于 0010 + 0010 等于 0100 等于 4

     右移即相反除以2
     0010 >>= 1 等于 0001

     在微软的编译器，汇编层会对2的倍数运算替换成位运算
     因为快，不是2的倍数即使用乘法运算比较慢
     可以通过debug 反汇编，查看位运算的指令和乘法指令对比
  */
}

int main()
{ 
  system("cls");
  test01();
  return 0;
}
